---
layout:     post
title:      "Data System Basic"
subtitle:   "Designing Data-Intensive Application 01"
date:       2020-06-03 23:55:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - DataBase
---

数据密集型应用系统设计摘要，第一部分

### 可靠、可扩展与可维护的应用系统
- 可维护性是指：可运维性，方便运营团队来保持系统平稳运行；简单性，简化系统复杂性，新工程师能够轻松理解系统；可演化性，后续工程师可以轻松对系统进行改进，根据需求将其适配到非典型场景

### 数据存储与检索
- 原则上可以在磁盘维护hash map，但存在这些问题：hash map需要大量随机访问IO；当hash map变满时，继续增长的代价很大；hash冲突需要复杂的处理逻辑

##### SSTable和LSM-Tree
- 排序字符串表SSTable，每个段都是一组kv对序列，按照key排序，每个键在每个合并的段文件中只出现一次
- 合并段，类似归并排序，各个段都是各自有序的。多个段包含相同键，保留最新段的键值
- 查找特定键值，内存可以保存键的稀疏索引，由于段是有序的，可以通过二分来查找，稀疏索引保证占用内存不会过多
- 工作流程如下：写入时，将键值对保存到内存中的平衡树数据结构（例如红黑树）；当内存大于某个阈值，将其作为SSTable文件写入磁盘，由于已通过平衡树排序，写入比较快；处理读请求，先在内存平衡树中查找，然后是最新的磁盘文件，接下来是次新的文件，以此类推；后台定期执行段合并与压缩
- 读取要遍历文件，一般会用布隆过滤器来排除大部分不存在的键

##### B-tree
- B-tree将数据分解成固定大小的页，这种设计接近硬件，因为磁盘也是以固定大小的块排列
- B-tree至少写两次数据，WAL和页。LSM-Tree合并也需要多次重写数据，但一般只需要顺序写，且对数据压缩/空间利用更友好
- LSM-Tree缺点在于重写数据会干扰读取，数据越多影响越大

##### 列式存储
- 每个列的所有值存储在一起，使用时只取出需要的列。适合压缩，例如使用位图表示该列有没有值，还可以对位图使用游程编码二次压缩
- 插入一行对于列式存储非常麻烦，最后只在尾部增加数据

### 编码与演化
- json/xml/csv等文本格式存在一些问题：对于数字，精度可能不足，不能处理大数字，区分不了数字和数字字符串，或者不区分整数和浮点数；不支持二进制字符串。优点在于通用
- 分开模式和数据，可以大大减少空间要求，更好兼容新旧系统，静态语言可以用模式进行类型检查
- 和Thrift以及ProtoBuf不一样，Avro没有字段标签编号，顺序很重要。它将编码和解码分开定义了写模式和读模式，字段通过名字标识，通过比对读写模式，来解决差异和兼容性