---
layout:     post
title:      "LKD Interrupt"
subtitle:   "中断和中断处理"
date:       2020-02-05 22:29:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - Linux
    - Linux Kernel
---

对应LKD3第7章中断和中断处理、第8章下半部和推后执行的工作。

- 中断是一种特殊的电信号，由硬件设备发向处理器，处理器马上中断当前自己的工作来处理中断信号。
- 响应中断时，内核会执行中断处理程序，它运行在中断上下文，不可阻塞。这属于上半部（top half）工作。允许稍后完成的工作会被推迟到下半部。
- 驱动程序可以通过request_irq()函数注册一个中断处理程序，注意这个函数可能会请求分配内存而导致进程睡眠。释放函数为free_irq。
- 中断处理程序无须重入，当一个给定中断处理程序正在执行，相应中断线在所有处理器上都会被屏蔽。不过通常情况下其它类型的中断是打开的。
- 中断上下文具有严格的时间限制，不会睡眠，打断其它代码甚至是其它中断线上的另一中断处理程序，所以必须尽可能快，而且部分工作要放到下半部执行。
- 中断处理程序有自己的栈，每个处理器一个，大小为一页。
- 2.6版本提供三种下半部实现机制：软中断、tasklets和工作队列。其中tasklet是通过软中断实现的。

### 软中断
- 软中断是编译期间静态分配的，最多32个软中断（目前用了9个）。一个软中断不会抢占另一个软中断，实际上唯一可以抢占软中断的是中断处理程序。其它的软中断（甚至是同类型）可以在其他处理器上同时执行。
- 中断处理程序会在返回前标记它的软中断，稍后软中断会被检查和执行：从一个硬件中断代码返回时，在ksoftirqd内核线程中，某些例如网络子系统会显式检查和执行待处理的软中断代码。
- 软中断执行函数为do_softirq()，过程就是简单的遍历标志位图，执行对应软中断处理函数。

### tasklet
- 有两种软中断属于tasklet，HI_SOFTIRQ和TASKLET_SOFTIRQ。唯一实际区别就是前者会先执行。
- 已触发的tasklet存放在两个单处理器数据结构tasklet_vec和tasklet_hi_vec。这两个链表中的每一项是tasklet_struct，代表一个不同的tasklet。所以执行tasklet所属软中断的时候，会去逐个尝试执行tasklet_struct链表项。注意，同一时间只能有同一类型的tasklet执行。
- 当一个软中断（包括tasklet）执行时，可以重新触发自己以便再次执行（网络子系统会这么干）。所以不能在处理软中断后马上再去尝试处理，否则系统会一直处理软中断。此时内核会唤醒一组内核线程来定期处理。

### 工作队列
- 工作队列总是将工作交由内核线程去执行，在进程上下文中，所以允许重新调度甚至是睡眠。
- 工作队列子系统是一个用于创建内核线程的接口，实际上有点像内核线程池。