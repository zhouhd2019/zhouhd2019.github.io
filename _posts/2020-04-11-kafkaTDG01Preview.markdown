---
layout:     post
title:      "kafkaTDG01"
subtitle:   "Preview"
date:       2020-04-11 00:35:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - kafka
    - mq
---

kafka The Definitive Guide(权威指南)摘要，对应第1、2章。

### 基本概念
- 消息可以没有键，kafka默认会用键来决定消息写入哪个分区
- 批次是一组消息，属于同一个主题和分区，会一次写入kafka，可以被压缩
- kafka通过主题对消息分类，主题可以被分为多个分区，消息以先进后出的顺序追加并被读取。无法保证整个主题内消息的顺序，只能保证单个分区的。分区可以分布在不同服务器
- 生产者默认将消息均衡发布到主题所有分区，也可以自定义分区器来映射消息到分区上
- 消费者把成功处理的消息的偏移量保存到kafka上，保证消息处理状态不会消失
- 多个消费者可以属于一个消费者群组，共同读取一个主题。群组保证每个分区只会被一个消费者使用。一个消费者失效，同一群组消费者可以接管它的工作
- 一个独立的kafka服务器被称为broker。接收生产者消息，为消息设置偏移量，提交消息到磁盘保存。对消费者的读取请求作出相应，返回已提交消息
- 每个集群有一个broker同时充当集群控制器的角色。一个分区从属于一个broker，该broker被称为该分区首领
- 消息默认保留策略是可以保留一段时间，或者保留到消息累积到一定大小。可以将主题配置成紧凑型日志，这样就只有每个键最新的消息被保留

### 参数调整
- num.partitions：分区数量指定后不能减少。大量的分区会更好分散负载，但有多个主题存在的情况下，会增加选举首领和达成同步的时间
- log.segment.bytes：日志片段大小太小，会频繁关闭和分配新文件，降低IO效率。太大，会使得片段过期时间变长，占用更多磁盘空间。类似参数有log.segment.ms，时间来控制片段关闭和新建
- message.max.bytes：单个消息压缩后的大小
- 系统虚拟内存vm.swappiness：一般为1，除非内存不足，否则不要虚拟内存
- 系统vm.dirty_background_ratio和vm.dirty_ratio：前者小一点，增加刷新脏页到硬盘的频率；后者大一点，增加用作脏页的内存空间的上限
- 系统noatime，不更新最后访问时间atime
- 系统网络，增加读写缓冲区和并发连接数，启用TCP时间窗扩展等等
- JAVA GC等参数
