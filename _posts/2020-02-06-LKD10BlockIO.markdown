---
layout:     post
title:      "LKD BlockIO"
subtitle:   "块I/O层"
date:       2020-02-06 22:18:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - Linux
    - Linux Kernel
---

对应LKD3第14章块I/O层。

- 能够随机（不按照顺序）访问固定大小数据片的硬件设备是块设备，固定大小的数据片被称为块。另一种基本设备是字符设备，按照字符流的方式被有序访问。
- 一个块在内存会被存储在一个缓冲区，一一对应，每个缓冲区有对应的描述符buffer_head。缓冲区头用于描述磁盘块和物理内存缓冲区之间的映射关系。
- 缓冲区头只能描述单个缓冲区，如果要对大块数据进行操作会非常麻烦。因此引入了bio结构体，来代表块I/O操作，保存所有涉及的缓冲区。这样即使缓冲区分散在内存多个位置上，bio也能对其执行I/O操作。
- bio->bi_io_vec指向一个bio_vec结构体数组，每个bio_vec都是(page, offset, len)这样的数据，描述块（对应一个缓冲区）所在物理页，块在物理页中的偏移和长度。
- 每个I/O请求可以由多个bio结构体组成，块设备会将I/O请求保存在请求队列。

### IO调度程序
- 块设备寻址很慢，所以为了优化寻址操作，内核会对IO请求进行合并和排序，合并相邻扇区的操作，将请求按照扇区增长方向有序排列。
- Linus电梯调度：如果已有相邻扇区请求，合并新请求和相邻请求；队列有驻留时间过长请求，新请求放到队列尾部；根据扇区方向为序寻找合适插入位置；上面的都不行就放到尾部。已被删除，不过新的算法以这种算法为基础。
- deadline IO调度：排序队列、读请求FIFO队列和写请求FIFO队列，三个队列，优先从FIFO中取超时请求，读请求的超时时间比写请求的要短很多，所有一定程度上读优先。
- 预测IO调度：请求提交后不直接返回处理其它请求，而是等待6ms，期间任何对相邻磁盘位置操作的新请求都会立刻得到处理，等待结束后继续执行以前的请求。
- 完全公正的排队IO调度：每个提交IO请求的进程都有对应的一个请求队列，分别进行合并和排序。调度程序以时间片轮转调度队列，从每个队列中选取一定数量的请求。
- 空操作IO调度：只进行合并，近乎FIFO，用在没有寻址负担的设备例如闪存。