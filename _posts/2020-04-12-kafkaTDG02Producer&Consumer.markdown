---
layout:     post
title:      "Producer & Consumer"
subtitle:   "kafkaTDG02"
date:       2020-04-12 16:35:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - kafka
    - mq
---

kafka The Definitive Guide(权威指南)摘要，对应第3、4章。

### 生产者
- 发送消息从创建ProducerRecord对象开始，包含目标主题和内容，可选指定分区或者键。序列化器将键值对序列化成字节数组，分区器选择一个分区。消息就会被添加到一个消息批次，这个批次的消息会被发送到相同的主题和分区，由独立线程负责发送到对应broker。如果消息成功写入kafka，就返回一个RecordMetaData，包含主题/分区信息/偏移量
- 发送消息有两种方式，同步发送检查future来获得结果，异步发送提供回调函数
- acks：指定必须有多少个分区收到消息，生产者才认为消息写入是成功。acks=0，生产者不会等待服务器的响应；acks=1，分区首领收到消息就算成功；acks=all，只有所有参与复制的节点收到消息，生产者才会收到一个来自服务器的成功响应
- batch.size，linger.ms：发送批次大小上限和最大等待时间
- max.in.flight.requests.per.connection：生产者收到服务器响应前能够发送多少个消息，设置为1就是即使需要重试的情况下，也能保证消息按顺序逐个发送
- max.request.size：发送请求大小上限，单个消息最大值和单个批次最大值

### 消费者
- 一个分区只会被一个消费者处理，多余消费者只会被闲置。不同消费者群组之间不会有影响
- 消费者的增加和减少会导致再均衡，一段时间内不可用。消费者通过向被指派为群组协调器的broker发送心跳来维持它们和群组的从属关系以及它们对分区的所有权关系，不同群组可以有不同的协调器broker。消费者停止发送心跳消息的时间足够长，协调器会认为它已经死亡，触发再均衡
- 轮询poll会处理包括群组协调、分区再均衡、发送心跳和获取数据等细节，第一次调用时会负责查找GroupCoordinator，然后加入群组接收分配的分区
- fetch.min.bytes：消费者从服务器获取记录的最小字节数，减少低谷时段的消耗
- session.timeout.ms：指定时间内没有发送心跳，就会被认为已死亡，触发再均衡
- auto.offset.reset：偏移量无效时的处理方法，默认latest，表示偏移量无效时，从最新的记录开始读取
- enable.auto.commit：默认自动提交偏移，不过可能出现重复和丢失
- 消费者往_consumer_offset主题发送消息来提交分区偏移量，触发再均衡时需要偏移量来保证能够接着之前的进度继续读取
- 提交偏移量可以自动提交、同步提交commitSync和异步提交commitAsync。commitSync会提交由poll返回的最新偏移量，会阻塞程序知道broker对提交请求作出回应。可以给commitAsync提供回调处理函数，来处理出错情况
- 提交偏移量一般可以使用异步提交，然后在关闭前使用同步提交
- commitSync和commitAsync可以传入分区和偏移量的map，来提交和poll不一样的偏移，例如处理一部分数据中途提交
- 消费者订阅主题时可以提供再均衡监听器，主要两个回调，一个是消费者停止读取消息后和再均衡开始前，另一个是重新分配分区后和消费者开始读取消息之前
- 可以在poll之前，通过seek来指定开始读取消息的偏移。常见做法是把之前处理过的偏移值和数据在同一个事务中存放到数据库，下次读取最新的偏移值继续处理，这样就可以保证不会漏处理或者重复处理
- 一个消费者如果订阅主题并加入消费者群组，可以选择自行分配分区