---
layout:     post
title:      "Detail"
subtitle:   "kafkaTDG03"
date:       2020-04-12 21:48:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - kafka
    - mq
---

kafka The Definitive Guide(权威指南)摘要，对应第5章。

### 控制器
- 集群每个broker都有唯一ID，启动时将自己ID注册到zookeeper。kafka组件订阅zookeeper的/brokers/ids，来获取broker加入或退出集群的通知
- 控制器是集群其中一个broker，负责分区首领的选举。首先成功在zookeeper创建控制器节点的broker就会称为控制器
- 当控制器发现一个broker退出集群，分区首领在这个broker的分区需要重选首领。控制器会指定其中一个副本为首领，接着向所有包含新首领和现有跟随者的broker发送通知
- 当一个broker加入集群，控制器会通过ID检查新加入broker是否包含现有分区的副本。如果有，控制器会通知新加入broker和其它broker，新broker会从首领那里复制消息

### 复制
- 副本有两种类型，首领和跟随者。每个分区有一个首领副本，所有生产者请求和消费者请求都会通过首领副本处理。跟随者副本不处理请求，唯一任务就是从首领复制消息，保持和首领一致，如果首领崩溃，跟随者会被提升为新首领
- 除了当前首领，每个分区都有一个首选首领。创建分区时需要在broker之间均衡首领，希望broker负载均衡。默认情况下，auto.leader.rebalance.enbale被设成true，kafka会检查首选首领是不是当前首领，如果不是并且首选首领副本是同步的，那么就会触发选举，让首选首领成为当前首领

### 处理请求
- broker会在它所监听的每个端口上运行Acceptor线程，接受的连接会交给Processor线程处理。Processor负责从客户端获取请求消息，并将它们放进请求队列；还负责从响应队列获取响应消息，把它们发给客户端
- 生产请求和获取请求都必须发给分区的首领副本。如果broker收到针对特定分区的请求，而该分区的首领在另一个broker，那么客户端会收到“非分区首领”的错误响应。kafka客户端需要自己负责把请求发送到正确的broker
- 客户端通过元数据请求来获取主题包含的分区信息、分区有哪些副本和副本首领所在等等信息，任意一个broker都缓存了这些信息。客户端需要偶尔发送元数据请求来刷新信息
- kafka采用零复制技术向客户端发送消息，直接将消息从内核文件缓存发送到网络通道，不需要经过用户态缓冲区
- 消息没有写入所有同步副本前，是不会发送给消费者的。replica.lag.time.max.ms，如果副本复制消息超出这个时间，则会被标记未非同步副本，一般不会被选为首领，在很多逻辑中也会被忽略

### 物理存储
- kafka会先随机选择一个broker存放首领分区0，然后依次选择后面序号的broker存放其它首领分区。对于跟随者副本分区，如果没有机架信息，会从首领分区所在broker开始，往后依次分配副本；如果有机架信息，则会交替机架，依次轮询
- 如果启动时启用了清理功能，broker会启动一个清理管理器线程和多个清理线程，为每个键只保留最新的值。每个片段可以分为两部分，清理过的干净部分和未清理过的污浊部分。清理线程会先读取分区的污浊部分，创建键到偏移量的map。接下来清理线程从头开始读取片段。如果键已经存在map中，说明后面有新的值，忽略；如果键不在map，则将消息复制到新的片段。