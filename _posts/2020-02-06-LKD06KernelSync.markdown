---
layout:     post
title:      "LDK Kernel Sync"
subtitle:   "内核同步"
date:       2020-02-06 16:31:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - Linux
    - Linux Kernel
---

对应LKD3第9章内核同步介绍、第10章内核同步方法。

- 内核中存在一些并发执行的情况，包括：中断、软中断和tasklet、内核抢占、睡眠、对称多处理器。
- 锁争用明显时，加锁太粗会降低可扩展性；锁争用不明显时，加锁过细会加大系统开销。设计处理的加锁方案要力求简单，仅当需要时再进一步细化加锁方案。

### 原子操作
- 针对整数的原子操作只能对atomic_t类型的数据进行处理，引入新类型而不是直接用int，原因在于：确保原子函数只与这些特殊类型的数据一起使用，保证这些类型的数据不会被传递给非原子函数；另外可以保证编译器不作出错误的优化；最后可以保证可移植性，屏蔽平台差异。
- atomic_t就是一个包含int的struct而已。在很多平台上读取一个字本身是一个原子操作，所以atomic_read可以直接返回atomic_t里面的整数。
- 除了整型，还有原子位操作
  
### 自旋锁和读写自旋锁
- 自旋锁只能被一个执行线程拥有，不可递归锁。
- 一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋，所以不应该被长时间持有。但由于不会睡眠，所以可以用在中断处理程序，有专门的spin_lock_irqsave()来禁止中断同时请求锁。
- 如果读写能够明确区分并且读取比较多，可以用读写自旋锁，读操作可以共享，写操作会等待读操作释放锁，写操作直接互斥。因此同一个执行线程递归获得读锁也是安全的。

### 信号量和读写信号量
- 如果有一个任务试图获得一个不可用的信号量，会被放进一个等待队列，然后进入睡眠。等信号量可用，处于等待队列中的任务将会被唤醒，并获得信号量。
- 信号量同时允许任意数量的锁持有者，在创建时指定。
- 读写信号量是互斥信号量，只能由唯一的写者。另外它比普通信号量多一种操作，就是支持写锁转换为读锁。

### 其它
- 互斥体mutex是一种比信号量更简单的睡眠锁，和使用计数为1的信号量类似。mutex上锁者必须负责解锁，不能跨进程。
- 完成变量用于一个任务发出信号通知另一任务发生了某个特定事件。
- 顺序锁用于写者非常少，并且写者优先的情况。实现依靠一个序列计数器，每次写操作会加一。读取数据前后需要读取并比较序号，一致则说明数据没有被修改。由于读取不会锁，所以只有一个写者时它总是能进行修改。
- 有明确依赖的代码不会被重排。读屏障rmb()保证，之前的载入操作不会被重新排在该调用之后，之后的载入操作不会重新排在该调用之前。写屏障wmb()则对存储进行顺序保证。