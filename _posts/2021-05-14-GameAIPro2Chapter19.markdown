---
layout:     post
title:      "Guide to Anticipatory Collision Avoidance"
subtitle:   "GameAIPro2 Chapter19"
date:       2021-05-14  16:05:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - GameAI
    - GameAIPro
    - GameAIPro2
    - GameProgramming
---

一种简单易懂的避让算法，有点避让算法入门的意思，后面还提到了ORCA

## 预测避让
- 算法目的是提前预见碰撞，而不是等到撞到了才分开。输入包括角色位置、半径和速度
- 对于两个角色，可以计算它们最快多久之后发生碰撞，无解表示不会碰撞，下面是伪代码
```
function ttc(i, j)
    r = r[i] + r[j]  // 距离平方
    w = x[j] - x[i]  // 半径之和平方
    c = dot(w, w) - r * r
    if (c < 0):  // 正在碰撞
        return 0
    v = v[i] - v[j]
    a = dot(v, v)
    b = dot(w, v)
    discr = b * b - a * c
    if (discr <= 0):  // 不会碰撞
        return INFTY
    tau = (b - sqrt(discr)) / a
    if (tau < 0):
        return INFTY
    return tau
```
- 只有碰撞时间在范围内，才会进行真正的避让。内敛角色可以将碰撞时间设置大一些，倾向于提前避开其它角色
- 如果当前偏离目标，需要把角色拉回来，可以用F_goal = k(v_goal - v)来表示拉力，其中v是当前速度，v_goal是指向目标的速度，k是可以调整的标量，用来调整力度大小，如果k太大，会覆盖其它力例如避让。每次计算就是简单的相加：v += F_goal * dt
- 避让力的方向是碰撞时两者位置相减所得向量。大小则可以根据碰撞时间来调整，时间越短，力度越大。设定一个力度最大值能够简化两者已经碰撞或者很接近的情况，临时减少两者半径在实践中表现也不错
- 实际计算就是对每个角色，计算它和每个可能碰撞的角色之间的避让力，加上它自身的目标拉力，乘以dt，得到的就是速度修改值，加上当前速度就是这次计算的结果速度

## 高级方法
- 如果要更好模拟人类的避让，需要考虑一些特殊因素：个人空间，两个角色之间尽可能不要擦肩而过，而是保持一定距离；FOV，只避让正面大概100度的扇形范围内的角色，背后角色看不到就不需要避让；避让距离，如果两者的碰撞点在个人空间内，则增大避让系数，如果在最大距离外，则不进行避让，简单来说就是分段式；加上一些随机性扰动，不要机械表现
- 上面的方法并不能保证没有碰撞，并且存在一些系数需要调整，而ORCA不需要特殊系数，并且基本可以保证没有碰撞
- ORCA算法中，可能碰撞的速度表示为圆头锥体VO，不会碰撞的可选速度则是它的补集
- ORCA作出以下规定：两个角色承担避让的一半责任；每个角色的可选速度是一个半平面，这样两个角色都有很大可选范围；相对速度的变化尽可能小
- 由于可选速度是半平面，所以避让计算就是多个半平面并集的补集，简单的线性规划问题
