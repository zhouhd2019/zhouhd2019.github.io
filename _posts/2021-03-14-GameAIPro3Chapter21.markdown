---
layout:     post
title:      "3D Flight Navigation Using Sparse Voxel Octress"
subtitle:   "GameAIPro3 Chapter21"
date:       2021-03-14  23:15:00
author:     "zhouhd"
header-img: "img/about-bg.jpg"
catalog: true
tags:
    - GameAI
    - GameAIPro
    - GameAIPro3
    - GameProgramming
---

## 概述
- 本文方法应用于Warframe，使用Sparse Voxel Octree来存储3D导航信息，并修改了A星算法处理寻路请求
- 路点图方法需要手工处理，在场景较大和资源变化频繁的游戏中不适用
- 多层导航图，对不同的高度生成多张导航网格，但难以处理好网格之间的移动，例如哪些地方可以移动，哪些不行。室内封闭场景比较适合这种方法
- 传统格子方法需要面对格子过多和搜索慢的问题
  
## Sparse Voxel Octrees
- 八叉树最高层只有1个节点，下一层8个节点，以此类推
- SVO在传统八叉树的基础上，能够针对位置快速查询，还存储了邻居连通性便于遍历
- SVO以Morton Code(莫顿码)顺序存储，将三维坐标映射到一维
- 对于非叶子节点，需要记录自己在空间的位置，需要有上一层和下一层的连接。非叶子节点都会有8个子节点，但只需要一个链接，因为节点都是用莫顿码来记录的。另外，每个非节点记录了周围6个同级节点用于遍历
- 每个叶子节点只需要一个位来记录有没有阻挡，因为对于4X4X4的体素，只需要64位来记录。叶子节点数量庞大，需要尽可能减少信息
- 数据结构尽量少用指针，而应该用整数偏移来指向别的节点，64位系统下指针要多一倍空间。32位整数的链接里，4位代表SVO层的索引，22位代表节点的索引，6位代表子节点的索引
- 构建SVO第一步是体素化，每个体素边长2m，则叶子节点边长8m(4X4X4个体素为一个叶子节点)，叶子节点上一层的边长则为16m。体素化完毕，就可以知道有多少种不重复的叶子节点
- SVO对于没有阻挡的节点，可以直接跳过，不存储它任何信息，例如子节点

## 寻路和其它细节
- 邻接节点信息在A星搜索时是必要的。如果某个节点的某个方向的同层节点为空，那么就应该将它该方向邻接节点设置为下一(N)层的非空节点。这样的话，需要注意搜索时可能会在层之间跳转
- 搜索时遇到叶子节点，注意叶子节点里面的体素没有邻接信息，4X4X4的信息存在64位整数中，需要特殊处理
- A星搜索时，可以将距离以体素为单位，同时在公式中加入对节点大小的考量，优先遍历更大的节点，不过这样会导致角色倾向于先去空旷的地方，而不是走最短路径
- JPS在3D下的表现一般，可能需要更多优化。层级搜索在树形结构中表现良好，不过需要更多的联通信息，可能会占用过多内存
